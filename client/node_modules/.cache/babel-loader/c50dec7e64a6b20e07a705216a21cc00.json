{"ast":null,"code":"\"use strict\";\n\nvar _interopRequire = function _interopRequire(obj) {\n  return obj && obj.__esModule ? obj[\"default\"] : obj;\n};\n\nvar _classCallCheck = function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar os = _interopRequire(require(\"os\"));\n\nvar EnumItem = _interopRequire(require(\"./enumItem\"));\n\nvar _isType = require(\"./isType\");\n\nvar isString = _isType.isString;\nvar isNumber = _isType.isNumber;\n\nvar indexOf = require(\"./indexOf\").indexOf;\n\nvar isBuffer = _interopRequire(require(\"is-buffer\"));\n\nvar endianness = os.endianness();\n/**\n * Represents an Enum with enum items.\n * @param {Array || Object}  map     This are the enum items.\n * @param {String || Object} options This are options. [optional]\n */\n\nvar Enum = function () {\n  function Enum(map, options) {\n    var _this = this;\n\n    _classCallCheck(this, Enum);\n    /* implement the \"ref type interface\", so that Enum types can\n     * be used in `node-ffi` function declarations and invokations.\n     * In C, these Enums act as `uint32_t` types.\n     *\n     * https://github.com/TooTallNate/ref#the-type-interface\n     */\n\n\n    this.size = 4;\n    this.indirection = 1;\n\n    if (options && isString(options)) {\n      options = {\n        name: options\n      };\n    }\n\n    this._options = options || {};\n    this._options.separator = this._options.separator || \" | \";\n    this._options.endianness = this._options.endianness || endianness;\n    this._options.ignoreCase = this._options.ignoreCase || false;\n    this._options.freez = this._options.freez || false;\n    this.enums = [];\n\n    if (map.length) {\n      this._enumLastIndex = map.length;\n      var array = map;\n      map = {};\n\n      for (var i = 0; i < array.length; i++) {\n        map[array[i]] = Math.pow(2, i);\n      }\n    }\n\n    for (var member in map) {\n      guardReservedKeys(this._options.name, member);\n      this[member] = new EnumItem(member, map[member], {\n        ignoreCase: this._options.ignoreCase\n      });\n      this.enums.push(this[member]);\n    }\n\n    this._enumMap = map;\n\n    if (this._options.ignoreCase) {\n      this.getLowerCaseEnums = function () {\n        var res = {};\n\n        for (var i = 0, len = this.enums.length; i < len; i++) {\n          res[this.enums[i].key.toLowerCase()] = this.enums[i];\n        }\n\n        return res;\n      };\n    }\n\n    if (this._options.name) {\n      this.name = this._options.name;\n    }\n\n    var isFlaggable = function isFlaggable() {\n      for (var i = 0, len = _this.enums.length; i < len; i++) {\n        var e = _this.enums[i];\n\n        if (!(e.value !== 0 && !(e.value & e.value - 1))) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    this.isFlaggable = isFlaggable();\n\n    if (this._options.freez) {\n      this.freezeEnums(); //this will make instances of Enum non-extensible\n    }\n  }\n  /**\n   * Returns the appropriate EnumItem key.\n   * @param  {EnumItem || String || Number} key The object to get with.\n   * @return {String}                           The get result.\n   */\n\n\n  Enum.prototype.getKey = function getKey(value) {\n    var item = this.get(value);\n\n    if (item) {\n      return item.key;\n    }\n  };\n  /**\n   * Returns the appropriate EnumItem value.\n   * @param  {EnumItem || String || Number} key The object to get with.\n   * @return {Number}                           The get result.\n   */\n\n\n  Enum.prototype.getValue = function getValue(key) {\n    var item = this.get(key);\n\n    if (item) {\n      return item.value;\n    }\n  };\n  /**\n   * Returns the appropriate EnumItem.\n   * @param  {EnumItem || String || Number} key The object to get with.\n   * @return {EnumItem}                         The get result.\n   */\n\n\n  Enum.prototype.get = function get(key, offset) {\n    if (key === null || key === undefined) {\n      return;\n    } // Buffer instance support, part of the ref Type interface\n\n\n    if (isBuffer(key)) {\n      key = key[\"readUInt32\" + this._options.endianness](offset || 0);\n    }\n\n    if (EnumItem.isEnumItem(key)) {\n      var foundIndex = indexOf.call(this.enums, key);\n\n      if (foundIndex >= 0) {\n        return key;\n      }\n\n      if (!this.isFlaggable || this.isFlaggable && key.key.indexOf(this._options.separator) < 0) {\n        return;\n      }\n\n      return this.get(key.key);\n    } else if (isString(key)) {\n      var enums = this;\n\n      if (this._options.ignoreCase) {\n        enums = this.getLowerCaseEnums();\n        key = key.toLowerCase();\n      }\n\n      if (key.indexOf(this._options.separator) > 0) {\n        var parts = key.split(this._options.separator);\n        var value = 0;\n\n        for (var i = 0; i < parts.length; i++) {\n          var part = parts[i];\n          value |= enums[part].value;\n        }\n\n        return new EnumItem(key, value);\n      } else {\n        return enums[key];\n      }\n    } else {\n      for (var m in this) {\n        if (this.hasOwnProperty(m)) {\n          if (this[m].value === key) {\n            return this[m];\n          }\n        }\n      }\n\n      var result = null;\n\n      if (this.isFlaggable) {\n        for (var n in this) {\n          if (this.hasOwnProperty(n)) {\n            if ((key & this[n].value) !== 0) {\n              if (result) {\n                result += this._options.separator;\n              } else {\n                result = \"\";\n              }\n\n              result += n;\n            }\n          }\n        }\n      }\n\n      return this.get(result || null);\n    }\n  };\n  /**\n   * Sets the Enum \"value\" onto the give `buffer` at the specified `offset`.\n   * Part of the ref \"Type interface\".\n   *\n   * @param  {Buffer} buffer The Buffer instance to write to.\n   * @param  {Number} offset The offset in the buffer to write to. Default 0.\n   * @param  {EnumItem || String || Number} value The EnumItem to write.\n   */\n\n\n  Enum.prototype.set = function set(buffer, offset, value) {\n    var item = this.get(value);\n\n    if (item) {\n      return buffer[\"writeUInt32\" + this._options.endianness](item.value, offset || 0);\n    }\n  };\n  /**\n   * Define freezeEnums() as a property of the prototype.\n   * make enumerable items nonconfigurable and deep freeze the properties. Throw Error on property setter.\n   */\n\n\n  Enum.prototype.freezeEnums = function freezeEnums() {\n    function envSupportsFreezing() {\n      return Object.isFrozen && Object.isSealed && Object.getOwnPropertyNames && Object.getOwnPropertyDescriptor && Object.defineProperties && Object.__defineGetter__ && Object.__defineSetter__;\n    }\n\n    function freezer(o) {\n      var props = Object.getOwnPropertyNames(o);\n      props.forEach(function (p) {\n        if (!Object.getOwnPropertyDescriptor(o, p).configurable) {\n          return;\n        }\n\n        Object.defineProperties(o, p, {\n          writable: false,\n          configurable: false\n        });\n      });\n      return o;\n    }\n\n    function getPropertyValue(value) {\n      return value;\n    }\n\n    function deepFreezeEnums(o) {\n      if (typeof o !== \"object\" || o === null || Object.isFrozen(o) || Object.isSealed(o)) {\n        return;\n      }\n\n      for (var key in o) {\n        if (o.hasOwnProperty(key)) {\n          o.__defineGetter__(key, getPropertyValue.bind(null, o[key]));\n\n          o.__defineSetter__(key, function throwPropertySetError(value) {\n            throw TypeError(\"Cannot redefine property; Enum Type is not extensible.\");\n          });\n\n          deepFreezeEnums(o[key]);\n        }\n      }\n\n      if (Object.freeze) {\n        Object.freeze(o);\n      } else {\n        freezer(o);\n      }\n    }\n\n    if (envSupportsFreezing()) {\n      deepFreezeEnums(this);\n    }\n\n    return this;\n  };\n  /**\n   * Return true whether the enumItem parameter passed in is an EnumItem object and \n   * has been included as constant of this Enum   \n   * @param  {EnumItem} enumItem\n   */\n\n\n  Enum.prototype.isDefined = function isDefined(enumItem) {\n    var condition = function condition(e) {\n      return e === enumItem;\n    };\n\n    if (isString(enumItem) || isNumber(enumItem)) {\n      condition = function condition(e) {\n        return e.is(enumItem);\n      };\n    }\n\n    return this.enums.some(condition);\n  };\n  /**\n   * Returns JSON object representation of this Enum.\n   * @return {String} JSON object representation of this Enum.\n   */\n\n\n  Enum.prototype.toJSON = function toJSON() {\n    return this._enumMap;\n  };\n  /**\n   * Extends the existing Enum with a New Map.\n   * @param  {Array}  map  Map to extend from\n   */\n\n\n  Enum.prototype.extend = function extend(map) {\n    if (map.length) {\n      var array = map;\n      map = {};\n\n      for (var i = 0; i < array.length; i++) {\n        var exponent = this._enumLastIndex + i;\n        map[array[i]] = Math.pow(2, exponent);\n      }\n\n      for (var member in map) {\n        guardReservedKeys(this._options.name, member);\n        this[member] = new EnumItem(member, map[member], {\n          ignoreCase: this._options.ignoreCase\n        });\n        this.enums.push(this[member]);\n      }\n\n      for (var key in this._enumMap) {\n        map[key] = this._enumMap[key];\n      }\n\n      this._enumLastIndex += map.length;\n      this._enumMap = map;\n\n      if (this._options.freez) {\n        this.freezeEnums(); //this will make instances of new Enum non-extensible\n      }\n    }\n  };\n  /**\n   * Registers the Enum Type globally in node.js.\n   * @param  {String} key Global variable. [optional]\n   */\n\n\n  Enum.register = function register() {\n    var key = arguments[0] === undefined ? \"Enum\" : arguments[0];\n\n    if (!global[key]) {\n      global[key] = Enum;\n    }\n  };\n\n  Enum.prototype[Symbol.iterator] = function () {\n    var _this = this;\n\n    var index = 0;\n    return {\n      next: function next() {\n        return index < _this.enums.length ? {\n          done: false,\n          value: _this.enums[index++]\n        } : {\n          done: true\n        };\n      }\n    };\n  };\n\n  return Enum;\n}();\n\nmodule.exports = Enum; // private\n\nvar reservedKeys = [\"_options\", \"get\", \"getKey\", \"getValue\", \"enums\", \"isFlaggable\", \"_enumMap\", \"toJSON\", \"_enumLastIndex\"];\n\nfunction guardReservedKeys(customName, key) {\n  if (customName && key === \"name\" || indexOf.call(reservedKeys, key) >= 0) {\n    throw new Error(\"Enum key \" + key + \" is a reserved word!\");\n  }\n}","map":null,"metadata":{},"sourceType":"script"}